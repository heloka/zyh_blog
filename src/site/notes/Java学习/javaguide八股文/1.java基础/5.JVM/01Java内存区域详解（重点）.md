---
{"dg-publish":true,"permalink":"/Java学习/javaguide八股文/1.java基础/5.JVM/01Java内存区域详解（重点）/"}
---

> 常见面试题：
>
> - 介绍下 Java 内存区域（运行时数据区）
> - Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
> - 对象的访问定位的两种方式（**句柄和直接指针两种方式**）
## 前言
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。
![Pasted image 20240122112015.png](/img/user/image/Pasted%20image%2020240122112015.png)
## 运行时数据区域包含哪些区域？ #五星
1. 运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享？【⭐⭐⭐⭐⭐】
- [终于搞懂了Java 8 的内存结构，再也不纠结方法区和常量池了！！ - Java技术栈 - 博客园 (cnblogs.com)](https://www.cnblogs.com/javastack/p/15153856.html)
Java 虚拟机在执行程序时，将所管理的内存划分成若干个不同的数据区域。主要分为两类，一类是由所有**线程共享**的数据区域，一类是**线程隔离**的数据区域。  线程共享的数据区域包含**方法区和堆内存**。  
线程隔离的区域包含**虚拟机栈，本地方法栈，以及程序计数器**。

JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。
**JDK 1.7**：
![image/f7b40044fc6085cba33dc0c3dc2f6e02_MD5.png](/img/user/image/f7b40044fc6085cba33dc0c3dc2f6e02_MD5.png)

**JDK 1.8**：
![image/ab4cc049a87fa739cc88a1c0fd9d7ff5_MD5.png](/img/user/image/ab4cc049a87fa739cc88a1c0fd9d7ff5_MD5.png)
**线程私有的：**
- **程序计数器**，用于记录当前线程执行的字节码指令地址。
- **虚拟机栈**，用于存储局部变量、操作数栈、方法出口等信息。
- **本地方法栈**，与Java虚拟机栈类似，但是为本地（Native）方法服务。
**线程共享的：**
- **Java堆**，用来存放对象实例。
- **方法区**：存放类的元信息、静态变量、常量池等数据。在HotSpot虚拟机中，方法区被称为永久代，但在较新的版本中被**元空间**（Metaspace）替代。
		- [[Java学习/javaguide八股文/1.java基础/5.JVM/01Java内存区域详解（重点）#方法区和永久代以及元空间是什么关系呢？ 四星\|01Java内存区域详解（重点）#方法区和永久代以及元空间是什么关系呢？ 四星]]
	- **直接内存** (非运行时数据区的一部分) :由NIO引入，使用Native函数库分配内存。不受Java堆大小限制，但属于一种比较特殊的堆外内存。
![Pasted image 20240111155547.png](/img/user/image/Pasted%20image%2020240111155547.png)

通过对比我们发现，在线程共享的区域中，JDK1.8有一个元空间代替了方法区。

### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
另外，为了线程切换后能恢复到正确的执行位置，**每条线程都需要有一个独立的程序计数器**，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
从上面的介绍中我们知道了程序计数器主要有**两个作用：**
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，**程序计数器用于记录当前线程执行的字节码指令地址**。
⚠️ 注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
### Java 虚拟机栈
- 与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。
- 除了Native方法以外的方法调用都是通过栈来实现的。
- 方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
- 栈由一个个栈帧组成，栈帧包括局部变量表、操作数栈、动态链接、方法返回地址。
![image/5fae915546c212a86c8a2a67f0918b56_MD5.png](/img/user/image/5fae915546c212a86c8a2a67f0918b56_MD5.png)

**局部变量表** 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
![image/18481ae3c2cfb809b6d68cf602c381b9_MD5.png](/img/user/image/18481ae3c2cfb809b6d68cf602c381b9_MD5.png)

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要**调用其他方法**的场景。
Class 文件的常量池里保存有大量的符号引用，比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用**转化为其在内存地址中的直接引用。**
![image/84d9381eadc02ee29e4f69ea09173691_MD5.png](/img/user/image/84d9381eadc02ee29e4f69ea09173691_MD5.png)


简单总结一下程序运行中栈可能会出现两种错误：
- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
### 本地方法栈
- 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 
	- 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。
### 堆
Java 堆是所有线程共享的内存区域，在虚拟机启动时创建。
1. **堆的作用：**
   - Java堆的主要目的是存放对象实例，几乎所有的对象实例和数组都在堆中分配内存。
      - Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
   - 堆是垃圾收集器管理的主要区域，也被称为GC 堆（Garbage Collected Heap）。

**2.堆的内存结构**
在 JDK 7及之前的版本，堆内存通常分为下面三部分：
1. 新生代内存(Young Generation)
2. 老年代(Old Generation)
3. 永久代(Permanent Generation)
下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。
![image/b4cef63524070616e83ad9a28a51c498_MD5.png](/img/user/image/b4cef63524070616e83ad9a28a51c498_MD5.png)

而在JDK 8及之后，永久代被元空间取代，元空间使用的是本地内存。
	- [[Java学习/javaguide八股文/1.java基础/5.JVM/01Java内存区域详解（重点）#方法区和永久代以及元空间是什么关系呢？ 四星\|01Java内存区域详解（重点）#方法区和永久代以及元空间是什么关系呢？ 四星]]
**堆中垃圾回收流程**
 - 大部分情况下，对象会首先在Eden区分配。在一次新生代垃圾回收后，如果对象仍然存活，将会晋升到Survivor区，并且年龄加1。  
 - 当对象年龄达到一定阈值（默认为15岁），就会晋升到老年代。晋升年龄阈值是动态计算的，通常与Survivor区的大小有关。
	 - Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当**累积的某个年龄大小超过了survivor区的一半时，取这个年龄和参数`-XX:MaxTenuringThreshold`中更小的一个值**，作为新的晋升年龄阈值。

堆中最容易出现的就是 `OutOfMemoryError` 错误，比如：
1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM **花太多时间**执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
2. **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置。

### 方法区 #三星
- 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。在不同的虚拟机实现上，方法区的实现是不同的。
- 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。
	- ps：这是逻辑定义，物理上静态变量和常量池已经存储在堆中了。
#### **方法区和永久代以及元空间是什么关系呢？** #四星
方法区和永久代以及元空间的关系可以理解为Java虚拟机对虚拟机规范中**方法区的两种实现方式**。并且永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。
![image/a3cd3d801b66909cc57ccffd28aa2810_MD5.png](/img/user/image/a3cd3d801b66909cc57ccffd28aa2810_MD5.png)
**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
1. **动态调整大小：** 永久代的大小是固定的，无法根据实际需要进行调整,容易导致内存溢出；**而元空间使用本地内存**，可以根据系统的实际可用内存动态调整大小。且元空间里面存放的是类的元数据，加载多少类的元数据而由系统的实际可用空间来控制，从而可以加载更多类的元数据。
2. **简化垃圾回收：** 永久代的对象是通过Full GC进行垃圾回收的，也就是和老年代同时实现垃圾回收，替换为元空间后，简化了Full GC的过程，可以在不进行暂停的情况下去并发地释放类的数据，同时也提升了GC的性能。
3. **代码合并优化**：JDK 8中，在合并HotSpot和JRockit的代码时，JRockit并没有永久代的概念。合并之后，JVM不再需要额外设置永久代。


> 当元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`
你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

**方法区常用参数有哪些？**
JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。
```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```
相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：
```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

### 运行时常量池
- 运行时常量池是方法区（Method Area）的一部分，也就是元空间（Metaspace）的一部分（在Java 8及以后的版本中）。在Java 7及之前的版本，它是永久代（PermGen）的一部分。
- 运行时常量池主要用于存储编译时期生成的**各种字面量和符号引用**。它是在类加载的过程中被创建和初始化的，同时也为运行时提供了一些动态性。
	- 字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。
- 值得注意的是，与Java中的常量池（例如字符串常量池）不同，运行时常量池是在**类加载的过程中被创建**的，而不是在运行时动态创建的。
- 在Java 8及以后的版本中，由于永久代的移除，[运行时常量池被移到了元空间](https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png)，而元空间属于本地内存，可以动态地增长或缩小，不再受到永久代的限制，使得运行时常量池可以更灵活地适应不同的应用场景。
### 字符串常量池
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
```java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```
HotSpot 虚拟机中字符串常量池的实现是 `StringTable` , 可以简单理解为一个固定大小的`HashTable` ，容量为 `StringTableSize`（可以通过 `-XX:StringTableSize` 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。

JDK1.7 之前，字符串常量池存放在永久代。从JDK1.7开始字符串常量池和静态变量从永久代移动了 Java 堆中。
![image/b17252238b0342fdf09e33ed909990ff_MD5.png](/img/user/image/b17252238b0342fdf09e33ed909990ff_MD5.png)
![image/c1b65ff4603e4ba74fe9f0452e4c5057_MD5.png](/img/user/image/c1b65ff4603e4ba74fe9f0452e4c5057_MD5.png)

**JDK 1.7 为什么要将字符串常量池移动到堆中？**
主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，JDK1.7选择将字符串常量池放到堆中，能够更高效及时地回收字符串内存。
相关问题：[JVM 常量池中存储的是对象还是引用呢](https://www.zhihu.com/question/57109429/answer/151717241)

> **运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

### 直接内存
**前置知识DirectByteBuffer**
- DirectByteBuffer是Java用于实现堆外内存的一个重要类，我们可以通过该类实现堆外内存的创建、使用和销毁。
- DirectByteBuffer该类本身位于Java内存模型的堆中。
- DirectByteBuffer中的unsafe.allocateMemory(size);是一个native方法，这个方法分配的是堆外内存，通过C的malloc来进行分配。

我们都知道Java程序是运行在Java虚拟机中的，Java对象的分配一般情况下是在虚拟机的堆内存空间，俗称堆内内存。这一块的内存垃圾回收是受JVM控制的，程序员无需为此处的内存回收而操心。Java对象除了能分配在堆中，也能分配在堆外，这部分内存叫堆外内存，也就是直接内存。

直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI（Java本地接口框架） 的方式在本地内存上分配的。
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。
JDK1.4 中新加入的 NIO 引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过 DirectByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆之间来回复制数据，提高了性能。

**直接内存和堆内内存的比较**
堆内内存的分配是在JVM中，因此分配速度很快，但是堆内内存在进行网络I/O的时候，需要先将内存从堆内复制到native堆。堆外内存的分配是直接调用的C的malloc函数在堆外空间分配的，因此分配速度相对较慢，但是在进行网络I/O的时候，由于没有将内存从堆内复制到native堆这一步，因此较快。
下图是发起一个网络请求时的内存数据流向图
![Pasted image 20240111181657.png](/img/user/image/Pasted%20image%2020240111181657.png)

## HotSpot 虚拟机对象
通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。
- 详细请看：[[Java学习/javaguide八股文/1.java基础/5.JVM/04类加载过程详解\|04类加载过程详解]]
### 对象的创建 #四星
#### Step1:类加载检查
虚拟机遇到一条 new 指令时，首先要去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并**检查这个符号引用代表的类是否已被加载过、解析和初始化过**。如果没有，那必须先执行相应的类加载过程。
#### Step2:分配内存
在**类加载检查**通过后，接下来虚拟机需要为新的对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，然后就**从Java 堆中划分出一块确定大小的内存**。内存分配的方式有两种：
- **指针碰撞**：
  - 适用场合：堆内存规整（即没有内存碎片）的情况下。
  - **原理**：用过的内存整合到一边，没有用过的内存放在另一边，中间有一个分界指针，可以**通过移动指针来分配内存**。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- **空闲列表：**
  - 适用场合：堆内存不规整的情况下。
  - 原理：维护一个列表，用来记录可用的内存块，分配时在列表中找到足够大的内存块进行划分，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS
选择哪种分配方式，取决于 Java 堆内存是否规整，而 Java 堆是否规整则取决于所采用的垃圾收集器的算法。
- 是"[[Java学习/javaguide八股文/1.java基础/5.JVM/02JVM垃圾回收详解（重点）#垃圾收集算法 五星\|标记-清除]]"，还是"标记-整理"和复制算法（规整）。

**内存分配并发问题**
在多线程环境下，对象的创建可能涉及到线程安全的问题，虚拟机采用两种方式来保证线程安全：
- **TLAB（Thread-Local Allocation Buffer）：** JVM启动时，为**每一个**线程预先在 Eden 区分配一块内存，这块内存是**线程独享的**。当JVM给线程中的对象分配内存时，首先会尝试在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用下面的CAS 方法进行内存分配。
- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突导致失败就进行重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
#### Step3:初始化零值
内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值**（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
#### Step4:设置对象头
初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 
另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
#### Step5:执行 init 方法
在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。
### 对象的内存布局
![Pasted image 20240122144026.png](/img/user/image/Pasted%20image%2020240122144026.png)
在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。
**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。
**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
### 对象的访问定位的两种方式 #五星
Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。
#### 句柄
   - 在Java堆中划分一块内存作为句柄池，reference中**存储的是对象的句柄地址**， 句柄中包含对象实例数据与对象类型数据各自的具体地址信息。
   - 优势： reference 中存储的是稳定的句柄地址，在对象移动时，只需修改句柄中的实例数据指针，reference本身不需修改。
![image/e919c5ddbb8e0ac52a89899f9b3d4145_MD5.png](/img/user/image/e919c5ddbb8e0ac52a89899f9b3d4145_MD5.png)
#### 直接指针
- reference中直接存储对象的地址。
- 优势：速度较快，省去一次指针定位的时间开销。
- HotSpot虚拟机主要使用这种方式进行对象访问。
![image/f66facd6ae1427428544b7676b18f862_MD5.png](/img/user/image/f66facd6ae1427428544b7676b18f862_MD5.png)