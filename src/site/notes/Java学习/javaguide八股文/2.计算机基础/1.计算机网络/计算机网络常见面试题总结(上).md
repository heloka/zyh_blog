---
{"dg-publish":true,"permalink":"/Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计算机网络常见面试题总结(上)/"}
---

## 计算机网络基础

### 网络分层模型

#### OSI 七层模型是什么？每一层的作用是什么？ #anki
**OSI 七层模型** 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：
-   物理层：透明地传输比特流。
-   数据链路层：组装成帧、差错控制、流量控制、传输管理（无拥塞控制）  
-   网络层：差错控制、流量控制、拥塞控制、网际互联（无连接+面向连接）  
-   运输层：端到端可靠传输、端到端流量控制、差错控制  
-   会话层：建立、管理、终止应用进程间的会话；使用校验点恢复通信、实现数据同步。
-   表示层：用于数据处理，比如格式转换，数据压缩，加密解密  
-   应用层 ：为计算机用户提供服务。 
![image/919ce08332db5982a5c7bbbcb16aa837_MD5.png](/img/user/image/919ce08332db5982a5c7bbbcb16aa837_MD5.png)

每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。
**OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。**


#### TCP/IP 四层模型是什么？每一层的作用是什么？ #anki

**TCP/IP 四层模型** 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：

![image/94155c060783fd04e42583bf761a3b36_MD5.png](/img/user/image/94155c060783fd04e42583bf761a3b36_MD5.png)

关于每一层作用的详细介绍，请看[[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/OSI 和 TCP，IP 网络分层模型详解（基础）\|OSI 和 TCP，IP 网络分层模型详解（基础）]]这篇文章。

#### 为什么网络要分层？ #anki
网络分层主要是为了简化网络的复杂性和提高其灵活性，主要有三方面的原因：
1. **各层之间相互独立**：网络分层后，各层之间是相互独立的，它们不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以理解为接口调用）。
2. **提高了灵活性和可替换性**：每一层都可以使用最适合的技术来实现，只需要保证你提供的功能以及暴露的接口规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。这就类似于我们平时开发系统的时候要求的**高内聚、低耦合的原则。**
3. **大问题化小**：通过分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题，可以使复杂的计算机网络系统变得易于设计和实现。

### 常见网络协议
#### 应用层有哪些常见的协议？ #anki

![image/8f0bc7a59d54b95a306b22b56633aec2_MD5.png](/img/user/image/8f0bc7a59d54b95a306b22b56633aec2_MD5.png)

- **HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
- **SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）**：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。
- **POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。
- **FTP（File Transfer Protocol，文件传输协议）** : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。
- **Telnet（远程登陆协议）**：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。
- **SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务
- **RTP（Real-time Transport Protocol，实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。
- **DNS（Domain Name System，域名管理系统）**: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

关于这些协议的详细介绍请看[[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/应用层常见协议总结（应用层）\|应用层常见协议总结（应用层）]] 这篇文章。

#### 传输层有哪些常见的协议？ #anki

![image/94dd5c042c3e97b225b6beee8d8f18a0_MD5.png](/img/user/image/94dd5c042c3e97b225b6beee8d8f18a0_MD5.png)

- **TCP（Transmission Control Protocol，传输控制协议 ）**：提供 **面向连接**的，**可靠**的数据传输服务。
- **UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。

#### 网络层有哪些常见的协议？ #anki

![网络层常见协议](/img/user/Java学习/javaguide八股文/2.计算机基础/1.计算机网络/images/network-model/nerwork-layer-protocol.png)

- **IP（Internet Protocol，网际协议）**：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。
- **ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。
- **ICMP（Internet Control Message Protocol，互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。
- **NAT（Network Address Translation，网络地址转换协议）**：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。
- **OSPF（Open Shortest Path First，开放式最短路径优先）** ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。
- **RIP(Routing Information Protocol，路由信息协议）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
- **BGP（Border Gateway Protocol，边界网关协议）**：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。

## HTTP
### 从输入 URL 到页面展示到底发生了什么？（非常重要） #anki
这道题应该在很后面才学。
> 类似的问题：打开一个网页，整个过程会使用哪些协议？
![image/Pasted image 20240407182000.png](/img/user/image/Pasted%20image%2020240407182000.png)

总体来说分为以下几个过程:

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

具体可以参考下面这两篇文章：

- [从输入 URL 到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)
- [浏览器从输入网址到页面展示的过程](https://cloud.tencent.com/developer/article/1879758)

### HTTP 状态码有哪些？ #anki

HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。

![image/3117d58a39fde206b78827f3b8fd9834_MD5.png](/img/user/image/3117d58a39fde206b78827f3b8fd9834_MD5.png)

关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：[[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/HTTP 常见状态码总结（应用层）\|HTTP 常见状态码总结（应用层）]]。

### HTTP Header 中常见的字段有哪些？
略。

### HTTP 和 HTTPS 有什么区别？（重要） #anki

![image/319bc00f0650dc7254b2b0e49f4de3be_MD5.png](/img/user/image/319bc00f0650dc7254b2b0e49f4de3be_MD5.png)

- **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，信息通过明文传输，客户端和服务器端都无法验证对方的身份。HTTPS 协议是由 SSL+HTTP 协议构建的可进行**加密传输**、身份认证的网络协议。HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
- **SEO（搜索引擎优化）**：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：[[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/HTTP vs HTTPS（应用层）\|HTTP vs HTTPS（应用层）]] 。

### HTTP/1.0 和 HTTP/1.1 有什么区别？ #anki

![image/c198e7423c7f807a1c47507b21115680_MD5.png](/img/user/image/c198e7423c7f807a1c47507b21115680_MD5.png)

- **连接方式** : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。
- **状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存机制** : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等。
- **带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

关于 HTTP/1.0 和 HTTP/1.1 更详细的对比总结，可以看我写的这篇文章： [[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/HTTP 1.0 vs HTTP 1.1（应用层）\|HTTP 1.0 vs HTTP 1.1（应用层）]] 。

### HTTP/1.1 和 HTTP/2.0 有什么区别？ #anki

![image/f07e7077c964f7b8d37b607c7fbfe79d_MD5.png](/img/user/image/f07e7077c964f7b8d37b607c7fbfe79d_MD5.png)

- **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。
- **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑高效，减少了传输的数据量和带宽消耗。
- **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。
- **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将**其他相关资源**一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

HTTP/2.0 多路复用效果图（图源： [HTTP/2 For Web Developers](https://blog.cloudflare.com/http-2-for-web-developers/)）：

![image/f91593156cf2dd6bac7ee5fb2fc6312f_MD5.png](/img/user/image/f91593156cf2dd6bac7ee5fb2fc6312f_MD5.png)

可以看到，HTTP/2.0 的多路复用使得不同的请求可以共用一个 TCP 连接，避免建立多个连接带来不必要的额外开销，而 HTTP/1.1 中的每个请求都会建立一个单独的连接

### HTTP/2.0 和 HTTP/3.0 有什么区别？ #anki

![image/bd6a1ecc46ac2585e9bf60b2d898dab1_MD5.png](/img/user/image/bd6a1ecc46ac2585e9bf60b2d898dab1_MD5.png)

- **传输协议**：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。可以将 QUIC 看作是 UDP 的升级版本，在 UDP 的基础上新增了很多功能，比如加密、重传等等。可以说，HTTP/3 最大的改造就是使用了 QUIC。
- **连接建立**：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。
- **队头阻塞**：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。
- **错误恢复**：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。
- **安全性**：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。

HTTP/1.0、HTTP/2.0 和 HTTP/3.0 的协议栈比较：

![image/5ccce60a4fbb4ccca20d15da3d8c12a6_MD5.png](/img/user/image/5ccce60a4fbb4ccca20d15da3d8c12a6_MD5.png)

关于 HTTP/1.0 -> HTTP/3.0 更详细的演进介绍，推荐阅读[HTTP1 到 HTTP3 的工程优化](https://dbwu.tech/posts/http_evolution/)。

### HTTP 是不保存状态的协议, 如何保存用户状态?

HTTP 协议是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同，服务器并不记得曾经访问过的这个客户。那么我们如何保存用户状态呢？
Session 机制的存在就是为了解决这个问题，Session 的主要作用就是**通过服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。
**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。
[[Java学习/Java核心基础/springSecurity学习#前置知识：Session、Cookie与Token\|springSecurity学习#前置知识：Session、Cookie与Token]]

### URI 和 URL 的区别是什么?  #anki

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### Cookie 和 Session 有什么区别？
[[Java学习/Java核心基础/springSecurity学习#前置知识：Session、Cookie与Token\|springSecurity学习#前置知识：Session、Cookie与Token]]


### GET 和 POST 的区别 #anki
这个问题在知乎上被讨论的挺火热的，[ GET 和 POST 到底有什么区别？ - 知乎](https://www.zhihu.com/question/28586791)
GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分：
- **语义**（**主要区别**）：GET 通常用于**获取或查询**资源，而 POST 通常用于**创建或修改**资源。
- **幂等**：GET 请求是幂等的，即多次重复执行**不会改变资源的状态**，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。
- **格式**：GET 请求的**参数通常放在 URL** 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过实际上，GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。-  [[日常记录/日记/URL请求参数怎么放\|URL请求参数怎么放]] -
- **缓存**：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行都需要实时响应。
- **安全性**：如果使用 HTTP 协议的话，GET 和 POST 都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 相比 POST 更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。

再次提示，重点搞清两者在**语义上**的区别即可，实际使用过程中，也是通过语义来区分使用 GET 还是 POST。不过，也有一些项目所有的请求都用 POST，这个并不是固定的，项目组达成共识即可。

## PING

### PING 命令的作用是什么？ #anki

PING 命令是一种常用的**网络诊断**工具，经常用来测试网络中主机之间的连通性和网络延迟。
如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对 ICMP 请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。


```bash
# 发送4个PING请求数据包到 www.baidu.com
❯ ping -c 4 www.baidu.com
正在 Ping www.a.shifen.com [183.2.172.185] 具有 32 字节的数据:
来自 183.2.172.185 的回复: 字节=32 时间=29ms TTL=53
来自 183.2.172.185 的回复: 字节=32 时间=28ms TTL=53
来自 183.2.172.185 的回复: 字节=32 时间=28ms TTL=53
来自 183.2.172.185 的回复: 字节=32 时间=28ms TTL=53

183.2.172.185 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 28ms，最长 = 29ms，平均 = 28ms
```

PING 命令的输出结果通常包括以下几部分信息：

1. **ICMP Echo Request（请求报文）信息**：序列号、TTL（Time to Live）值。
2. **目标主机的域名或 IP 地址**：输出结果的第一行。
3. **往返时间（RTT，Round-Trip Time）**：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。
4. **统计结果（Statistics）**：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。


### PING 命令的工作原理是什么？ #anki

PING 基于网络层的 **ICMP（互联网控制报文协议）**，主要是通过在网络上发送和接收 ICMP 报文实现的。

ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：
- **查询报文**：向目标主机发送请求并期望得到响应。
- **差错报告报文**：向源主机发送错误信息，用于报告网络中的错误情况。

PING 使用的 ICMP 回送请求和回答报文属于**查询报文**。使用 PING 命令会向目标主机发送 ICMP 回送请求报文，如果两个主机的**连通性正常**，目标主机会返回一个对应的 ICMP 回送回答报文。

## DNS

### DNS 的作用是什么？ #anki
域名系统 DNS 是互联网使用的命名系统，它是用户使用浏览器访问网址之后使用的第一个重要协议。DNS 主要解决的是**域名和 IP 地址的映射问题**。

![image/504addbdcbbc9fb91ca273a025f9c7d9_MD5.png](/img/user/image/504addbdcbbc9fb91ca273a025f9c7d9_MD5.png)

在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，那么就需要依靠 DNS 进行查询了。

目前 DNS 的设计采用的是分布式、层次数据库结构，DNS 是一个**应用层**协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53。

### DNS 服务器有哪些？ #anki
DNS 服务器自底向上可以依次分为以下几个层级。  
-   **根域名服务器**是最高层次的域名服务器。它们知道所有顶级域名服务器的域名和 IP 地址，当本地域名服务器无法解析域名时，首先就要向根域名服务器发出查询请求。  
-   **顶级域名服务器**，顶级域是指域名的后缀,比如 `com`、`org`、`net` 和 `edu` 、`uk` 、`cn` 等等。TLD 服务器提供了权威 DNS 服务器的 IP 地址。
- **权威域名服务器**，每个在因特网上拥有**公共可访问**主机的组织，都必须提供公共可访问的 DNS 记录，这些记录负责将主机的域名映射为相应的 IP 地址。
-   **本地域名**服务器，每个 ISP 都有一个自己的本地 DNS 服务器。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。本地 DNS 服务器起着代理的作用，并将请求转发到 DNS 层次结构中。严格来说，本地 DNS 服务器**不属于** DNS 的层次结构。

### DNS 解析的过程是什么样的？ #anki

整个过程的步骤比较多，我单独写了一篇文章详细介绍：[[Java学习/javaguide八股文/2.计算机基础/1.计算机网络/计网重要知识点/DNS 域名系统详解（应用层）\|DNS 域名系统详解（应用层）]]

## 参考

- 《图解 HTTP》
- 《计算机网络自顶向下方法》（第七版）
- 详解 HTTP/2.0 及 HTTPS 协议：<https://juejin.cn/post/7034668672262242318>
- HTTP 请求头字段大全| HTTP Request Headers：<https://www.flysnow.org/tools/table/http-request-headers/>
- HTTP1、HTTP2、HTTP3：<https://juejin.cn/post/6855470356657307662>
- 如何看待 HTTP/3 ？ - 车小胖的回答 - 知乎: <https://www.zhihu.com/question/302412059/answer/533223530>

<!-- @include: @article-footer.snippet.md -->