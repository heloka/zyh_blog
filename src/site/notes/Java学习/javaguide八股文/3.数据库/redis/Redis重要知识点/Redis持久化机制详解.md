---
{"dg-publish":true,"permalink":"/Java学习/javaguide八股文/3.数据库/redis/Redis重要知识点/Redis持久化机制详解/"}
---

使用缓存的时候，我们经常需要**对内存中的数据进行持久化**，也就是将内存中的数据写入到硬盘中。
大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据）；
或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。

Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:
- 快照（snapshotting，RDB）
- 只追加文件（append-only file, AOF）
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)
## RDB快照如何实现
RDB快照是Redis持久化的一种机制，它记录了Redis在某一瞬间的内存数据状态。与AOF日志不同，RDB保存的是实际的数据，而AOF保存的是执行的命令。
因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。

### RDB 做快照时会阻塞线程吗？ #四星

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：
-   执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
-   执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**.
    
Redis 的快照是**全量快照**，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。

###  RDB 在执行快照的时候，数据能修改吗？
Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别在于是否在「主线程」里执行。

在bgsave过程中，主线程仍然可以处理操作命令，允许数据修改，关键在于**写时复制技术。
- 执行`bgsave`命令的时候，会通过`fork()`创建子进程，子进程和父进程共享相同的内存数据。
- 在`bgsave`过程中，如果主线程要**修改共享数据**，就会发生写时复制。这块数据的物理内存会被复制一份，然后主线程对这个数据副本进行修改操作，同时 `bgsave` 子进程把**原来的数据**写入 RDB 文件。
- 注意，主线程刚修改的数据不能在这一时间写入RDB文件，只能交由下一次的`bgsave`快照。
写时复制技术确保在生成RDB快照的过程中，不会影响主线程的正常操作，并保留了快照时刻的数据状态。
[RDB 快照是怎么实现的？](https://xiaolincoding.com/redis/storage/rdb.html)

## AOF 持久化
### 什么是 AOF 持久化？ #三星
AOF 持久化以独立**日志**的方式记录每次写入的命令。每执行一条修改数据的命令，Redis 都会将该命令追加到 AOF 缓冲区中。随后写入 AOF 文件，此时数据仍在**系统内核缓存区**，最后根据**持久化策略**来决定何时将数据同步到硬盘中。
只有在同步到磁盘后，才算完成了持久化保存，否则仍存在数据丢失的风险。
- 例如：系统内核缓存区的数据尚未同步，但磁盘机器宕机，那这部分数据就算丢失了。
- 不过与快照持久化相比，AOF**持久性实时性**更好,当进程意外退出时丢**失的数据更少**

### AOF 工作基本流程是怎样的？
1. **命令追加（Append）**：所有写命令都被追加到AOF缓冲区中。
2. **文件写入（Write）**：将 AOF 缓冲区的数据写入到 AOF 文件中。此阶段通过调用系统调用中的`write`函数实现，`write`将数据写入系统内核缓冲区，但此时并未立即同步到硬盘。
	- `write` 用于将数据写入内核缓冲区，不会立即同步到磁盘，这种延迟写提高了效率但带来了数据丢失的风险。
3. **文件同步（Fsync）**：AOF 缓冲区根据**指定的持久化策略**与硬盘同步。通过调用 `fsync` 函数对 AOF 文件进行强制硬盘同步，`fsync` 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
	- `fsync`用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。
4. **文件重写（Rewrite）**：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
5. **重启加载（Load）**：当Redis重启时，可以加载AOF文件进行数据恢复。

AOF 工作流程图如下：

![image/18411c5f7526650eab9adac7fd95db33_MD5.png](/img/user/image/18411c5f7526650eab9adac7fd95db33_MD5.png)

### AOF 持久化方式有哪些？ #三星

Redis 有三种 AOF 持久化方式（ `fsync`策略），分别是：
1. `appendfsync always`：主线程调用 `write` 执行写操作后，后台线程**立即调用** `fsync` 函数同步 AOF 文件（刷盘），`fsync` 完成后线程返回，这会对 Redis 性能产生较大影响，因为每次写操作都需要等待磁盘同步完成。（`write` + `fsync`）。
2. `appendfsync everysec`：主线程调用 `write` 执行写操作后立即返回，由后台线程每秒钟调用 `fsync` 函数同步一次（`write`+`fsync`，`fsync`间隔为 1 秒）
3. `appendfsync no`：主线程调用 `write` 执行写操作后立即返回，让操作系统决定何时进行同步。（`write`但不`fsync`，`fsync` 的时机由操作系统决定）。

**这 3 种持久化方式的主要区别在于 `fsync` 同步 AOF 文件的时机（刷盘）**。

为了兼顾数据和写入性能，可以考虑 `appendfsync everysec` 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。


从 Redis 7.0.0 开始，Redis 使用了 **Multi Part AOF** 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：

- BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。
- INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。
- HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。

Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的[Redis 7.0 Multi Part AOF 的设计和实现](https://zhuanlan.zhihu.com/p/467217082) 这篇文章。

**相关 issue**：[Redis 的 AOF 方式 #783](https://github.com/Snailclimb/JavaGuide/issues/783)。

### AOF 为什么是在执行完命令之后记录日志？  #四星

关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。

![image/85ec4a49aa9d0be3d1a115aeb84341e8_MD5.png](/img/user/image/85ec4a49aa9d0be3d1a115aeb84341e8_MD5.png)

**为什么是在执行完命令之后记录日志呢？**
- **避免额外的检查开销**，因为 AOF 记录日志**不会对命令进行语法检查**，先写入日志可能会造成之后数据恢复出错；
- **不会阻塞当前写操作命令的执行**：在命令执行完之后再记录，不会阻塞当前的命令执行。

这样也带来了风险：
- **数据可能丢失：** 由于 AOF 是在执行完命令后记录日志，如果刚执行完命令 Redis 就宕机，可能导致对应的修改丢失；
- **可能会阻塞后续其他命令**： 因为 AOF 记录日志是在主线程中进行的，所以当 Redis 把日志文件写入磁盘时，还是会阻塞后续的操作无法执行。

### AOF 重写了解吗？（AOF日志过大，会触发什么机制） #三星

当 AOF 变得太大时，Redis 能够在后台自动重写，产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

**AOF 重写流程**
![Pasted image 20240117200455.png](/img/user/image/Pasted%20image%2020240117200455.png)
1. **子进程：** 由于 AOF 重写涉及到大量的写入操作，为了避免对 Redis 正常的命令造成影响，Redis 将 AOF 重写程序放到**子进程**里执行。
2. **维护 AOF 重写缓冲区：** 在重写过程中，Redis 会维护一个 AOF 重写缓冲区，用于记录**在重写期间**服务器执行过的所有写命令。
3. **追加内容：** 当子进程创建好新的 AOF 文件后，服务器会将 **AOF 重写缓冲区**中的所有内容追加到**新 AOF 文件的末尾**。这样可以确保新 AOF 文件保存的数据库状态与现有数据库状态一致。
4. **替换文件：** 最后，服务器会用新的 AOF 文件替换原有的 AOF 文件，完成 AOF 重写操作。

**AOF 重写的启动条件**
AOF 重写可以手动启动，也可以根据一些配置项在满足条件时自动触发：
- `BGREWRITEAOF` 命令：手动触发 AOF 重写。
- `auto-aof-rewrite-min-size`：AOF 文件大小小于该值时，不会触发 AOF 重写，默认为 64 MB。
- `auto-aof-rewrite-percentage`：当前 AOF 文件大小**相对于上一次 AOF 重写时的大小的增长百分比**达到设定值时，触发 AOF 重写，默认为 100。

Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。

Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的[从 Redis7.0 发布看 Redis 的过去与未来](https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg) 这篇文章。

> AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。
>
> 阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。

**相关 issue**：[Redis AOF 重写描述不准确 #1439](https://github.com/Snailclimb/JavaGuide/issues/1439)。

### AOF 校验机制了解吗？

AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。
这个机制的原理是通过使用一种叫做**校验和（checksum）** 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和，从而判断 AOF 文件是否完整。
如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。


## Redis 4.0 对于持久化机制做了什么优化？（混合持久化）

由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

混合持久化工作在 **AOF 日志重写过程**，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的AOF重写子进程首先将**与主线程共享的内存数据**以RDB格式写入到 AOF 文件的前半部分。
主线程继续处理操作命令，这些命令会被记录在重写缓冲区里，这个重写缓冲区中的增量命令以 AOF 格式写入到 AOF 文件的后半部分。
**写入完成后**，通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。
也就是说，使用了混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**。

**优点：**
- 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，降低了数据丢失的风险。
**缺点：**
- AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
- 兼容性差，如果开启混合持久化，生成的 AOF 文件就不能用在 Redis 4.0 之前的版本。

## 如何选择 RDB 和 AOF？
在选择 Redis 的持久化方式时，我们需要考虑 RDB 和 AOF 的优势和劣势。
### RDB 的优势
1. **数据备份和灾难恢复**：RDB 文件存储的是经过**压缩的二进制数据**，文件相对较小，适合做数据备份和灾难恢复。相比之下，AOF 文件存储的是每次的写命令，因此通常会比 RDB 文件大很多。
2. **快速数据恢复**：在需要恢复数据时，RDB 文件可以直接解析并还原数据，不用像 AOF 那样逐条执行写命令，因此恢复速度更快。
### AOF 的优势
1. **持久化效率**：
- AOF 支持实时或秒级的持久化操作，这取决于 `fsync` 策略的设置。而且 AOF 操作轻量，只是将简单地将命令追加到文件中。
- 相比之下，RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。而且生成 RDB 文件的过程也比较繁重，会对机器的 CPU 资源和内存资源产生影响，甚至可能导致 Redis 服务宕机。
2. **兼容性**：
- 最后，RDB 文件是以特定的二进制格式保存的，随着 Redis 版本的演进，可能会存在老版本不兼容新版本 RDB 格式的问题。
- 而 AOF 文件以易于理解和解析的格式记录所有操作的日志，便于导出进行分析。
### 综合选择建议
1. 若数据丢失对系统影响不大，可选择使用 RDB 进行定期备份。
2. 虽然 AOF 提供了更高的数据安全性，但由于其恢复速度较慢，不建议单独使用。定时创建 RDB 快照可以进行数据库备份、快速重启，以及解决 AOF 引擎错误。
3. 可以同时开启 RDB 和 AOF 持久化，或采用混合持久化策略。这样可以在保证数据安全性的同时，兼顾数据恢复的速度和效率。
