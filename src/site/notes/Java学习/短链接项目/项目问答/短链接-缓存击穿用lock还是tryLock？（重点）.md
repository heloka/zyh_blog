---
{"dg-publish":true,"permalink":"/Java学习/短链接项目/项目问答/短链接-缓存击穿用lock还是tryLock？（重点）/"}
---

短连接解决缓存击穿问题的 Redisson 为什么不用 trylock。反正获取不到锁就已经说明有线程去处理，为什么要让她一直阻塞等待获取锁？黑马点评用的 trylock 我感觉没问题
难道就是单纯为了用一个双重判断锁吗？前几天美团被问到了，然后挂了，说我对整个技术方案不理解，为了写亮点而去写技术
使用 trylock，那未获取到锁的线程如何处理？直接返回错误吗，不是应该得跳转然后记录日志？那往哪跳转呢，查询数据库拿到原始链接？
[知识星球 | 深度连接铁杆粉丝，运营高品质社群，知识变现的工具 (zsxq.com)](https://wx.zsxq.com/dweb2/index/topic_detail/5122188248845514)
## 前置知识
在 Redisson 中，`lock()` 和 `tryLock()` 都是用于获取锁的方法，但它们的行为和特性有所不同。
1.  `lock()`:
    -   `lock()`方法会**阻塞当前线程**，直到获取到锁为止。也就是说，如果锁当前被其他线程或进程占用，那么调用`lock()`的线程将会等待，直到锁被释放并成功获取到锁。
    -   由于其阻塞性质，`lock()`方法可能会导致线程挂起，从而影响系统的并发性能。
    -   在使用`lock()`时，需要特别注意死锁和锁等待的问题，避免系统陷入僵持状态。
2.  `tryLock()`:
    -   `tryLock()`方法会尝试获取锁，如果锁当前可用，则立即返回并获取锁；如果锁不可用（即已被其他线程或进程占用），**则立即返回失败**，不会阻塞当前线程。
    -   `tryLock()`方法提供了更高的灵活性，允许线程在等待锁的过程中执行其他任务，从而提高系统的并发性能。
    -   使用`tryLock()`时，需要处理获取锁失败的情况，例如通过重试机制或其他策略来确保线程能够最终获取到锁并执行相应的任务。


看了这个帖子感觉有点纠结 lock 和 tryLock，那么从两个的问题以及适用场景分析，在这里我统一回复下。
## lock 有什么问题？  
lock 的问题在于，发生缓存击穿的时候，大几千、几万甚至几十万的请求时候，会有大量资源**阻塞等待**获取分布式锁。  
假设短链接缓存过期了，然后同一时间有 10 个请求获取原始链接跳转，这时逻辑如下所示：  
1. 请求获取到分布式锁；  
2. 读取数据库拿到原始链接；  
3. 将原始链接数据放到缓存；  
4. 请求释放分布式锁，等待下一个请求获取锁。  
假设一次逻辑执行是 50ms，第 10 个请求获取到执行完逻辑再返回大概需要 500ms。
![image/Pasted image 20240409175935.png](/img/user/image/Pasted%20image%2020240409175935.png)
用双重判定锁进行优化后，除了第一个请求需要查数据库，耗时多点外，剩下的请求就是获取锁、查询缓存以及释放锁了。  
[[日常记录/日记/分布式锁和本地锁#解释\|分布式锁和本地锁#解释]]
这样一来第一个请求耗时是 50ms，而之后的请求大概在 1ms-5ms 左右。查询缓存非常非常快。  
![image/Pasted image 20240409180004.png](/img/user/image/Pasted%20image%2020240409180004.png)
但是，哪怕使用双重判定锁，依然会有上述请求等待问题。假设缓存过期的时候，有 1w 个请求顺时获取这个缓存，那么极大可能最后一个获取锁的响应时间是 10050ms，这种肯定会有问题的。
不过上面说的是非常非常极端的场景，或者说基本上不可能出现。Why？但凡这种级别的热数据，缓存不会让它过期。哪怕咱们短链接场景，恰巧短链过期了，然后 N 个用户请求，这种场景是否存在都需要打个问号。  
不过高级程序员难得的是：考虑极端场景，并且优化它。
### **1. 分布式锁切换本地锁**  
[[日常记录/日记/分布式锁和本地锁#分布式锁切换本地锁的解析\|分布式锁和本地锁#分布式锁切换本地锁的解析]]
分布式锁涉及到网络 IO ，性能肯定不如本地锁，而且如果当时 Redis 遇到大 Key 或者热 Key 等问题，执行性能还会下降，为此，我们可以使用本地锁。  
Q：用了本地锁有没有问题？是否会有分布式环境下数据错乱的情况？  
A：因为我们使用本地锁**查询数据**，并不会有任何问题。而且相对于分布式锁来说，同时查询数据库的请求会更多些。比如我们短链接服务部署了 20 个节点，那么同一时间就有 20 个请求访问数据库，分布式锁只会有一个。  
但是这些数据请求就是洒洒水而已，相反性能还提升了 20 倍。而且，随着这个节点的增多，性能提升会更多。使用分布式锁解决缓存击穿是 10050ms，那使用本地锁部署 20 个节点，单个节点服务最多就是 550 毫秒左右。  
**计算公式**：1w请求 / 20 节点 = 500（单个节点请求），500 请求中第一个耗时 50ms，剩下 499 个请求单个 1ms 左右。  

### 2. 节点数不够怎么办？  
上面的场景取决于部署节点需要很多才行，但是很多场景下部署节点不会太多，这种怎么解决？  
那我们就能通过初始化 N 个本地锁，然后我们通过短链接进行 Hash % N 进行取余。这样的话，通过我们**初始化多个锁**来提高这种并行性能。  

## 能不能用 tryLock？  
首先，tryLock 是什么？尝试获取锁，**如果获取不到锁直接返回**，不像 lock 一样阻塞住获取锁。tryLock 因为是快速失败，所以不存在像上面的阻塞问题。  
优点是**不阻塞用户请求**，大量用户缓存击穿不会有阻塞行为。缺点也很明显，用户体验感极差。  
试想，你创建了个短链接，然后缓存失效了，可能有几百个用户同一时间访问，只有一个用户返回成功，其余用户返回了 404，你作为用户想不想骂街。  
有些用户是没有再刷新一次的习惯的，这些用户投诉的成本，都要远高于多部署几台服务节点或者多搞几个本地锁实例的成本。
>一旦出现缓存失效还有几千个访问，你还在那里阻塞然后再发一次 redis 网络请求。大量线程阻塞 CPU 负载过高导致整个服务崩溃，最终所有使用这个系统的用户导致的崩溃比你几个用户投诉的成本大多了

PS：Redisson 的分布锁之间的线程阻塞和唤醒是靠 redis 的发布订阅机制以及 Semaphore 信号量来控制的，被阻塞的线程会让出 cpu 并不会使其负载过高。另外，系统在架构设计时本身肯定会集成 Hystrix 或者 Sentinel 这种应对 **限流+熔断+服务降级** 的框架。

面试过程中真的理解 lock 和 tryLock 了么？有和面试官讲清楚两者优缺点了么？任何一种方案都有适用场景，你要做的就是把方案优缺点讲出来，说出自己的倾向点，然后和面试官探讨。

**分布式场景下分布式锁换本地锁**
解释：考虑到资源问题，本身短链是有可能和其他项目共享 redis 的，如果每一条短链都用分布式锁的话，占用会很大，而且只是读取请求使用本地锁的话，假如你 10 个服务，每个服务 3 个锁，请求打到数据库也没有特别大的负载，但是可以节省很大的 redis 内存开销。这本身也是资源和性能的取舍。
关于 tryLock 和 lock 的选择，这需要根据具体的业务需求来决定。还有就是，对于这样的热点数据本身可以做**缓存预热**等操作，极端场景首先想到应该是避免这样的情况，而解决办法是由你和面试官沟通得到。
在应对系统崩溃的情况时，应该采用限流、熔断和服务降级等方式，直接使用 tryLock 会降低用户体验，可以在服务降级后再使用。



## 什么场景用 lock 或者 tryLock？  
总结下，什么场景用 lock？什么场景用 tryLock？  
如果是类似于**秒杀**那种用户占便宜再或者真的海量的场景，应该使用 **tryLock** 方式。用户占便宜场景返回失败自己会刷新，海量访问不使用 tryLock 是不行的，容易堵塞用户请求。如果是类似于做 SaaS 短链接场景，用 tryLock 的话肯定就不行了，会被用户投诉。  
注意这里说的海量不是几万场景，因为如果短链接缓存过期击穿，几万的请求同一时间来，通过搞几个本地锁就能解决。  
所以，综上所述，短链接使用 lock 没问题（使用 tryLock 也没问题），我们可以使用多点**本地锁**实例进行分流提升响应性能即可。
如果面试官举例说**大几十万请求来了阻塞怎么办**？如果在没有风控系统或者限流熔断拦截的前提下，tryLock 算的上是最佳选择。  
不存在绝对的银弹，而是和面试官聊清楚 lock 和 tryLock 的应用场景，**不同场景下的解决方案是不一致的**。

