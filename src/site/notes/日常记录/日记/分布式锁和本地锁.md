---
{"dg-publish":true,"permalink":"/日常记录/日记/分布式锁和本地锁/"}
---

**项目相关**：
- [[谷粒商城-商品秒杀模块\|谷粒商城-商品秒杀模块]]
- 短链接->针对缓存读取功能进行优化，利用**双重检验锁**有效解决了在更新或失效场景下**大量请求查询数据库**的问题。


场景描述：
n 个请求就多一次 Redis 网络请求，n 个线程阻塞抢锁导致服务器资源占用多最终系统崩溃，反而你直接返回错误让用户刷新一次去再请求短链接，这样系统可用性更高？是这样吗？

ps：首先本地锁和分布式锁的范围不一样，比如有 10 个节点，每个节点能有 3 把锁，如果用本地锁同时可能会存在 30 把锁，分布式锁的情况则只能存在 3 把，毕竟是本地的。本地锁更多，意味着同时能够处理的线程会更多，理论上性能会更好。

### 前言
感觉本地锁涉及到 java 并发编程里面的知识，而分布式锁则是 redis。

### 本地锁
​ 在**单进程**的系统中，当存在**多个线程**可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行，**以防止并发修改变量带来数据不一致或者数据污染的现象**。  
​而为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。

本地锁在分布式环境下，是**没有办法锁住其他节点的操作**的。
对于单机多线程来说，在 Java 中，我们通常使用 `ReetrantLock` 类、`synchronized` 关键字这类 JDK 自带的 **本地锁** 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。

### 分布式锁
[[日常记录/日记/分布式锁常见五种方案-转载#一、本地锁的问题\|分布式锁常见五种方案-转载#一、本地锁的问题]]
在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。
为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即**同一时刻只允许一个线程访问共享资源**，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。




### 参考文献
- [本地锁和分布式锁的理解 - 风不辞 - 博客园 (cnblogs.com)](https://www.cnblogs.com/balloon72/p/13177929.html)

### 双检锁解释
分布式下lock 阻塞等待，
![image/Pasted image 20240409193506.png](/img/user/image/Pasted%20image%2020240409193506.png)
双检锁的原理：判断 redis 有无数据->没有，请求获取锁->查数据库前再看看 redis 有无数据->没有，查数据库，放入缓存->释放锁。

我懂了，所以才是用 **lock 阻塞等待+ 双检锁**，因为这个时候，有一个线程获取到锁，去查完数据库并且写入缓存，他执行的是全套流程。
而别的线程执行了一半，卡在了获取锁这里，正在阻塞等待中，等第一个线程释放锁，其余线程由于双重检验锁的优化，又去看看 redis 是否有数据，有数据？那没事了，执行正常监控记录逻辑，走人。

如果是 tryLock 就不需要双重检验锁吧？ 因为快速失败了。

### 分布式锁切换本地锁的解析
本地锁 lock 方法，也是阻塞等待的，这意味着双重检验锁的逻辑依然可以成立，我们部署的每个节点都有一个线程要去数据库查询数据缓存？比如我们短链接服务部署了 20 个节点，那么**同一时间**就有 20 个请求访问数据库，分布式锁只会有一个。  （由于这 20 个请求都是同时访问数据库，理论上查数据库的开销还是 50ms，但是数据库查询次数变多了）
但是除此之外，我们有 20 倍的性能提升，因为 20 个节点都能在阻塞等待获取到锁之后，发现 redis 已经查过了，然后执行其他逻辑，锁的获取速度快了 20 倍（不过应该有水分吧，因为多了 19 次额外的查询数据库开销）。


### 商品秒杀逻辑解析
下单时需要判断以下问题：
* 秒杀是否**开始或结束**，如果尚未开始或已经结束则无法下单（普通业务逻辑）
* **库存是否充足，不足则无法下单（超卖问题）
* 是否**重复下单**（一人一单）

**整体逻辑：** 秒杀商品时，先判断活动是否还有效，如果时间充足，则进一步判断**库存是否足够**，然后再根据用户 id 查询**是否已经下过订单** ，如果下过订单则不再下单，否则扣减库存，创建订单。

#### 超卖问题解决
每扣减一次库存，库存量都会发生改变，所以我们完全可以用**库存量**来做标志，标志当前库存量是否被其他线程更改过（在这种情况下，库存量的功能和版本号类似）
省流：使用乐观锁**CAS** 解决，逻辑是**判断当前库存是否大于 0**：
```java
// 扣减库存
Boolean success = seckillVoucherService.Update ()
                 .setSql ("stock = stock - 1") // set stock = stock - 1
               .eq ("voucher_id", voucherId). Gt ("stock", 0) // where id = ? And stock > 0
                    .update ();
```

如果我们设定逻辑为 `判断刚查询的库存和扣除时的库存是否相等` ，则会出现问题：假如多个线程都判断到不相等了，那它们都停止了扣减，这时候就没办法卖了。
而 `判断当前库存是否大于 0`，则可以很好地解决上述问题。
#### 一人一单问题
在**扣除库存**前，先去查数据库**是否已经有了该用户的订单**了；如果有了，说明该用户已经下单过了，不能再购买；如果没有，则执行扣除操作并生成订单。
这一操作有线程安全问题，需要加锁：
> 1.  判断当前用户在数据库中并没有订单
> 2.  执行扣除操作，并生成订单

**解决办法：**
使用 Redission 分布式锁来锁住同一用户 id，确保同一用户不重复下单。

**问题 ：** 如果线程发生阻塞，一直不释放锁（删除 key）怎么办？（redis 实现分布式锁常见问题）
设置合理的锁超时时间。但是**超时时间**是一个非常不好把握的东西，因为业务线程的阻塞时间是不可预估的。

**解决方案：** 在每一次释放锁之前，**判断**当前的锁**是否属于自己这个线程，** 这样就避免了释放别人锁的情况。  
**核心逻辑：** 在存入锁时，放入自己**线程的标识**，在删除锁时，判断当前这把锁是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。

#### 分布式锁的原子性问题
一个持有锁的线程 1 想要释放锁，当他执行完条件判断： `当前锁是当前线程的锁`，正准备释放锁的时候发生了阻塞，如果此时线程 2 获取到了锁，正在执行业务的时候，线程 1 从阻塞中恢复了，但是由于已经完成了条件判断，它会直接释放掉线程 2 的锁，这就是释放锁的原子性问题。

这是因为释放锁的逻辑分为两步走，是非原子的：
> 1.  **判断**当前的锁**是否属于自己这个线程**
> 2.  当前线程释放锁
**分步执行，并发问题！**

**这是一个原子性的问题，刚刚释放锁的两步应该是原子的，不可分的！**
要使得其满足原子性，则需要在 Redis 中**使用 Lua 脚本**了。
到了目前为止，我们设计的 Redis 分布式锁已经是生产可用的，相对完善的分布式锁了。
[[谷粒商城-商品秒杀模块#总结\|谷粒商城-商品秒杀模块#总结]]





